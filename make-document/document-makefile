#!/bin/bash

usage() {
    echo "There are two options to run $0."
    echo -e "\t1. $0 -D /path/to/all/makefiles\t(expands to *.mk)"
    echo -e "\t--OR--"
    echo -e "\t2. $0 path/to/makefile another/makefile"
    }

verbose=0
directory=""
outfile="tables.pdf"
while getopts ":D:vho:" opt
do
    case $opt in 
	o)
	    outfile=$OPTARG
	    if [[ $outfile != *.pdf ]]
	    then
		outfile=${outfile}.pdf
	    fi
	    ;;
	D)
	    if [ -d $OPTARG ]
	    then
		directory=$OPTARG
		echo "Reading all *.mk files from $directory"
	    else
		echo "$OPTARG is not a directory."
		usage
		exit 1
	    fi
	    ;;
	v)
	    verbose=1
	    shift
	    ;;
	h)
	    usage
	    exit 0
	    ;;
	\?)
	    echo "-$OPTARG is not a valid option"
	    usage
	    ;;
    esac
done

# remove flags and their arguments, keep the rest as input
shift $(( $OPTIND - 1 ))

if [ "$directory" = "" ]
then
    # if no directory was supplied, take all arguments
    files=$@
else
    # if a directory was supplied, use it.
    files=$directory/*
fi

if [ $verbose -eq 1 ] ; then echo $files ; fi

mkdir -p sdmf-output/

rm sdmf-output/header.txt
for i in ${files}
do
    echo $(basename $i) >> sdmf-output/header.txt
done

python sdmf-scripts/makemakedoc.py ${files}

if [ ! -s targets.txt ] || [ ! -s intermediates.txt ] || [ ! -s variables.txt ]
then
    echo "One or more output files is empty. This probably isn't what you want; check your inputs."
   exit 1
fi

# format for LaTeX, if python succeeded
if [ $? -eq 0 ]
then
    for file in targets.txt variables.txt
    do
	# sanitize & (remove from comments before proceeding)
	sed -i -e 's/\&/and/g' ${file} 

	# swap ; for & and add \\ to EOL
	sed -i -e 's/;/\&/g' -e 's/$/ \\/' ${file}

	# escape $, %, #, &, allow breaking at ':', '/'
	sed -i -e 's/[\$\#]/\\&/g' -e 's/%/{\\color{blue}\\%}/g' -e 's/[:/]/\\discretionary{&}{}{&}/g' ${file}
    done

    # collapse second and third cols of variables.txt into a single cell
    gawk -i inplace 'BEGIN {FS="&"} ; {print $1" & ""\\texttt{"$2"} \\newline "$3" &"$4}' variables.txt
    # TO DO trim variable definitions to 120 characters (approx. three lines)
    
    # escape $, %, #, & in intermediates.txt
    sed -i -e 's/\&/\\\&/g' intermediates.txt
    sed -i -e 's/[\$\#]/\\&/g' -e 's/%/{\\color{blue}\\%}/g' intermediates.txt
    gawk -i inplace 'BEGIN {FS=";"} ; {print "\\item [\\texttt{"$1"}] (\\texttt{\\hyperref["$3"]{"$3"}}) "$2}' intermediates.txt

else
    exit 1
fi

touch variables.txt
touch targets.txt
touch intermediates.txt

mv variables.txt sdmf-output/
mv targets.txt sdmf-output/
mv intermediates.txt sdmf-output/

echo "Running PdfLaTeX ..."

> sdmf-scripts/makefiles.tex
for i in ${files}
do
    if [[ $i == *"_"* ]] ; then
	echo "Bash: LaTeX doesn't like underscores in filenames."
	echo -e "\tPlease rename your files if you wish to continue using SDMF."
	exit 1
    fi

    echo "\subsection{\texttt{"$(basename ${i})"}}" >> sdmf-scripts/makefiles.tex
    echo "\label{"$(basename ${i})"}" >> sdmf-scripts/makefiles.tex
    echo "\lstinputlisting{../"${i}"}" >> sdmf-scripts/makefiles.tex
done

echo $latexout

cd sdmf-scripts
if [ $verbose -eq 1 ] ; then
    # output all of pdflatex's gobbledygook
    pdflatex -shell-escape -synctex=1 -interaction=nonstopmode tables.tex 
    pdflatex -shell-escape -synctex=1 -interaction=nonstopmode tables.tex 
else
    # redirect STDOUT to /dev/null
    pdflatex -shell-escape -synctex=1 -interaction=nonstopmode tables.tex 1 > /dev/null
    pdflatex -shell-escape -synctex=1 -interaction=nonstopmode tables.tex 1 > /dev/null  
fi
cd ..
cp sdmf-scripts/tables.pdf sdmf-output/$outfile

echo "Saved to sdmf-output/$outfile"